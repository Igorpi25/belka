type Project
  @model(
    queries: { list: "listProjects" },
    # create Project mutation has custom logic
    mutations: { update: "updateProject", delete: "deleteProject" },
    subscriptions: { level: ON }
  )
  @versioned
  @auth(rules: [
    { allow: owner },
    { allow: owner, ownerField: "team" },
    # { allow: owner, ownerField: "freelancers", operations: [create] }
    # {allow: groups, groups: ["Managers"], queries: null, mutations: [create, update, delete]},
    # {allow: groups, groups: ["Employees"], queries: [get, list], mutations: null}
  ])
{
  id: ID!
  owner: String
  team: [String!]
  managers: [String!]
  accauntants: [String!]
  warehousemans: [String!]
  freelancers: [String!]
  name: String
  description: String
  client: String
  status: ProjectStatus
  spec: Spec @connection
  createdAt: String
	updatedAt: String
}

enum ProjectStatus {
  IN_PROGRESS
  COMPLETED
  ARCHIVED
}

type Spec
  @model(queries: { get: "getSpec" }, mutations: null, subscriptions: null)
  @auth(rules: [
    { allow: owner },
    { allow: owner, ownerField: "team" },
  ])
{
  id: ID!
  owner: String
  team: [String]
  waybills: [Waybill!] @connection(name: "SpecWaybills")
}

type Waybill
  @model(
    queries: { get: "getWaybill" },
    # create, update, delete Waybill mutation has custom logic
    mutations: null,
    subscriptions: { level: ON }
  )
  @versioned
  @auth(rules: [
    { allow: owner },
    { allow: owner, ownerField: "team" },
  ])
{
  id: ID!
  owner: String
  team: [String!]
  number: String
  description: String
  contractor: String
  purchaseDate: String
  deliveryDate: String
  spec: Spec @connection(name: "SpecWaybills")
  waybillSpecId: ID!
  products: [Product!] @connection(name: "WaybillProducts")
  status: WaybillStatus
  # profitType, profitPercent - recalc products
  # profitForAll - restore products prices and reset customProfit field
  # discount, prepayment - recalc waybill residue and customerDebt
  profitType: WaybillProfitType
  profitPercent: Float
  profitForAll: Boolean
  discount: Int
  prepayment: Float
  prepaymentDate: String
  residue: Float
  residueDate: String
  customerDebt: Float
  customerDebtDate: String
  totalAmount: Float
  totalClientAmount: Float
  totalNet: Float
  totalGross: Float
  totalCapacity: Float
  totalCargoPlaceCount: Float
  createdAt: String
	updatedAt: String
}

enum WaybillProfitType {
  MARGIN
  COMMISSION
}

enum WaybillStatus {
  IN_PROCESSING
  IN_PRODUCTION
  IN_STOCK
}

type Product
  @model(
    queries: null,
    # create, update, delete Product mutation has custom logic
    # on create waybill status should change
    mutations: null,
    subscriptions: { level: ON }
  )
  @versioned
  @auth(rules: [
    { allow: owner },
    { allow: owner, ownerField: "team" },
  ])
{
  id: ID!
  owner: String
  team: [String!]
  article: String
  name: String
  quantity: Int
  # TODO add connection with type ProductUnit, array in project
  unit: String
  customProfit: Boolean
  cost: ProductCost
  store: ProductStore
  info: ProductInfo
  link: ProductLink
  status: ProductStatus
  waybill: Waybill @connection(name: "WaybillProducts")
  productWaybillId: ID!
  createdAt: String
	updatedAt: String
}

enum ProductStatus {
  IN_PROCESSING
  IN_PRODUCTION
  IN_STOCK
}

type ProductCost {
  owner: String
  team: [String!]
  price: Float
  amount: Float
  clientPrice: Float
  clientAmount: Float
}

type ProductStore {
  owner: String
  team: [String!]
  net: Float
  gross: Float
  width: Float
  height: Float
  length: Float
  capacity: Float
  inStock: Boolean
  cargoPlaceCount: Float
  # TODO add connection with type CargoPlace, @model
  cargoPlaceNumber: Int
}

type ProductInfo {
  owner: String
  team: [String!]
  images: [String]
  description: String
}

type ProductLink {
  owner: String
  team: [String!]
  url: String
}

type Subscription {
  onCreateProject(owner: ID!): Project
    @aws_subscribe(mutations: ["createProject"])
  onCreateWaybill(owner: ID!): Waybill
    @aws_subscribe(mutations: ["createWaybill"])
  onUpdateWaybill(owner: ID!): Waybill
    @aws_subscribe(mutations: ["updateWaybill"])
  onDeleteWaybill(owner: ID!): Waybill
    @aws_subscribe(mutations: ["deleteWaybill"])
  onCreateProduct(owner: ID!): Product
    @aws_subscribe(mutations: ["createProduct"])
  onUpdateProduct(owner: ID!): Product
    @aws_subscribe(mutations: ["updateProduct"])
  onDeleteProduct(owner: ID!): Product
    @aws_subscribe(mutations: ["deleteProduct"])
}

type Mutation {
  createProject(input: CreateProjectInput!): Project
    @function(name: "belkaapiGraphQLResolver-${env}")
  createWaybill(input: CreateWaybillInput!): Waybill
    @function(name: "belkaapiGraphQLResolver-${env}")
  updateWaybill(input: UpdateWaybillInput!): Waybill
    @function(name: "belkaapiGraphQLResolver-${env}")
  deleteWaybill(input: DeleteWaybillInput!): Waybill
    @function(name: "belkaapiGraphQLResolver-${env}")
  createProduct(input: CreateProductInput!): Product
    @function(name: "belkaapiGraphQLResolver-${env}")
  updateProduct(input: UpdateProductInput!): Product
    @function(name: "belkaapiGraphQLResolver-${env}")
  deleteProduct(input: DeleteProductInput!): Product
    @function(name: "belkaapiGraphQLResolver-${env}")
}

# fake update
input CreateProjectInput {
  id: ID
  owner: String
  team: [String!]
  managers: [String!]
  accauntants: [String!]
  warehousemans: [String!]
  freelancers: [String!]
  name: String
  description: String
  client: String
  status: ProjectStatus
  createdAt: String
  updatedAt: String
  projectSpecId: ID
}

input CreateWaybillInput {
  id: ID
  owner: String
  team: [String!]
  number: String
  description: String
  contractor: String
  purchaseDate: String
  deliveryDate: String
  waybillSpecId: ID!
  status: WaybillStatus
  profitType: WaybillProfitType
  profitPercent: Float
  profitForAll: Boolean
  discount: Int
  prepayment: Float
  prepaymentDate: String
  residue: Float
  residueDate: String
  customerDebt: Float
  customerDebtDate: String
  totalAmount: Float
  totalClientAmount: Float
  totalNet: Float
  totalGross: Float
  totalCapacity: Float
  totalCargoPlaceCount: Float
  createdAt: String
  updatedAt: String
}

input UpdateWaybillInput {
  id: ID!
  owner: String
  team: [String!]
  number: String
  description: String
  contractor: String
  purchaseDate: String
  deliveryDate: String
  waybillSpecId: ID
  status: WaybillStatus
  # excluded fields that has affect to calcs
  # profitType, profitPercent, profitForAll, discount, prepayment - values to trigger calc
  # residue, customerDebt - values do should do not change from client?
  profitType: WaybillProfitType
  profitPercent: Float
  profitForAll: Boolean
  discount: Int
  prepayment: Float
  prepaymentDate: String
  residue: Float
  residueDate: String
  customerDebt: Float
  customerDebtDate: String
  totalAmount: Float
  totalClientAmount: Float
  totalNet: Float
  totalGross: Float
  totalCapacity: Float
  totalCargoPlaceCount: Float
  createdAt: String
  updatedAt: String
}

input DeleteWaybillInput {
  id: ID
}

input CreateProductInput {
  id: ID
  owner: String
  team: [String!]
  article: String
  name: String
  # on create quantity default is 0
  unit: String
  status: ProductStatus
  customProfit: Boolean
  productWaybillId: ID!
  createdAt: String
  updatedAt: String
}

input UpdateProductInput {
  id: ID!
  owner: String
  team: [String!]
  article: String
  name: String
  # quantity update trigger calc
  quantity: Int
  unit: String
  customProfit: Boolean
  # cost update trigger calc
  cost: ProductCostInput
  # quantity trigger calc
  store: ProductStoreInput
  info: ProductInfoInput
  link: ProductLinkInput
  status: ProductStatus
  createdAt: String
  updatedAt: String
}

input DeleteProductInput {
  id: ID
}

input ProductCostInput {
  owner: String
  team: [String!]
  price: Float
  amount: Float
  clientPrice: Float
  clientAmount: Float
}

input ProductStoreInput {
  owner: String
  team: [String!]
  net: Float
  gross: Float
  width: Float
  height: Float
  length: Float
  capacity: Float
  inStock: Boolean
  cargoPlaceCount: Float
  cargoPlaceNumber: Int
}

input ProductInfoInput {
  owner: String
  team: [String!]
  images: [String]
  description: String
}

input ProductLinkInput {
  owner: String
  team: [String!]
  url: String
}
